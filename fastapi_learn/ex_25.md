# Q: Can you change the code to simulate async dependencies with with custom Depends class...

To simulate async dependencies, we need to modify the depends function to be an async function that performs asynchronous operations. You can use await inside the dependency function to simulate a real-world async operation.

Additionally, in your example, you're using yield in the async function, which requires special handling to properly await and resolve the dependency. However, it seems like you're trying to simulate resource management using yield in an async context, similar to what FastAPI's dependency injection system does.

Let's change the code accordingly to handle async dependencies properly.

```sh
python  ex_25.py

Before route handling
depends core
** Calling dependency. But not sure if it is sync or async.
== Result of dependency know. Now detecting is sync or async.
:: This is an async dependency.
try to open resource
resource opened
closing resource
After route handling with result: {'item_id': 101, 'dep': 'dependency result'}

{'item_id': 101, 'dep': 'dependency result'}

Before route handling
depends core
** Calling dependency. But not sure if it is sync or async.
try to open resource
resource opened
closing resource
== Result of dependency know. Now detecting is sync or async.
:: This is a sync dependency.
After route handling with result: {'item_id': 102, 'dep': 'sync dependency result'}

{'item_id': 102, 'dep': 'sync dependency result'}
```

## Explanation:

1. Calling dep_func():

   - You first call the dep_func(), which might be a sync or async function.

2. Checking if it's an Async Generator:

   - If the dep_func() returns an async generator (i.e., it yields values asynchronously), we process it by iterating through the generator using async for and returning the first yielded value.

3. Sync Dependency Handling:
   - If the result isn't an async generator, it's treated as a sync dependency and directly returned.

## Why Simplify:

- No Double isinstance Check: Since AsyncGenerator check already handles the async nature, you don't need another dep_func() call or check afterward. The simplified version checks for async generators and directly returns the result for sync functions.

## Output:

This should ensure that the function behaves correctly for both sync and async dependencies, and it should resolve your concern of repeated function calls.

# Conclusion:

For the synchronous dependency function, we can't use the resource outside the function since it's closed immediately after the function execution. In contrast, with the asynchronous version, the resource remains available throughout the route handling, as it is only closed after the @app_get decorator completes.

In conclusion, when using synchronous dependencies, the resource is opened and closed within the dependency function itself, making it unsuitable for use outside the function's scope. However, for asynchronous dependencies, the resource stays open for the duration of the route's execution, ensuring that it remains available until the decorator completes, allowing more flexibility for resource management during request handling. This distinction is crucial when designing APIs that rely on external resources, such as databases or file systems, as the timing of resource access and cleanup varies between sync and async contexts.
