# Q: Can you change the code to simulate async dependencies with with custom Depends class...

To simulate async dependencies, we need to modify the depends function to be an async function that performs asynchronous operations. You can use await inside the dependency function to simulate a real-world async operation.

Additionally, in your example, you're using yield in the async function, which requires special handling to properly await and resolve the dependency. However, it seems like you're trying to simulate resource management using yield in an async context, similar to what FastAPI's dependency injection system does.

Let's change the code accordingly to handle async dependencies properly.

```sh
% python  ex_25.py

Before route handling
depends core
This is an async dependency.
try to open resource
resource opened
closing resource
After route handling with result: {'item_id': 101, 'dep': 'dependency result'}

{'item_id': 101, 'dep': 'dependency result'}

Before route handling
depends core
try to open resource
resource opened
closing resource
This is a sync dependency.
After route handling with result: {'item_id': 102, 'dep': 'sync dependency result'}

{'item_id': 102, 'dep': 'sync dependency result'}
```

## Explanation:

1. Calling dep_func():

   - You first call the dep_func(), which might be a sync or async function.

2. Checking if it's an Async Generator:

   - If the dep_func() returns an async generator (i.e., it yields values asynchronously), we process it by iterating through the generator using async for and returning the first yielded value.

3. Sync Dependency Handling:
   - If the result isn't an async generator, it's treated as a sync dependency and directly returned.

## Why Simplify:

- No Double isinstance Check: Since AsyncGenerator check already handles the async nature, you don't need another dep_func() call or check afterward. The simplified version checks for async generators and directly returns the result for sync functions.

## Output:

This should ensure that the function behaves correctly for both sync and async dependencies, and it should resolve your concern of repeated function calls.

## What the Code Does:

- Async Dependency (some_dependency): Opens and closes the resource asynchronously, yields the result, and the cleanup is triggered after the result is consumed.
- Sync Dependency (sync_dependency): Opens and closes the resource synchronously using time.sleep(), and the cleanup happens after the result is returned.
- Route Handling: The route simulates processing the item_id and dep arguments, with dependency injection happening dynamically.

This setup is flexible and could be extended to handle more complex use cases like handling multiple dependencies, injecting dependencies into multiple functions, or simulating more complex resource management scenarios.
