# Q: Can you write your own app.get decorator as app_get to simulate the process of decorator injection?

## A: Yes! You can simulate the behavior of FastAPI's @app.get() decorator with a custom decorator (@app_get()) to understand how dependency injection works.

Here's a simplified version that mimics the process of calling a dependency resolver when a route is invoked:

### Steps:

1. Create a custom app_get() decorator: This will simulate registering routes and handling requests.
2. Manually handle dependencies: The decorator will simulate FastAPI’s process of resolving and injecting dependencies.
3. Invoke the handler: When a request is "made," the decorator will resolve the dependencies and pass them to the route handler.

## How This Works:

1. app_get() Decorator:

   - It wraps the route handler and simulates dependency injection.
   - When the route handler is called, it checks for any dependencies (callables) in the function arguments.
   - If it finds a dependency (like some_dependency), it calls the dependency manually and injects the result into the function.

2. depends() Function:

   - This function simulates FastAPI’s Depends(). It takes a dependency function and returns its result, simulating the resolution of dependencies.

3. Dependency Injection Simulation:
   - When read_item(101) is called, the custom decorator injects the resolved value of some_dependency() (i.e., "dependency result") into the dep argument of the read_item function.

```json
% python ex.24.py
{ "item_id": 101, "dep": "dependency result" }
```

This simulates how FastAPI handles dependency injection when using @app.get() and Depends(). The custom app_get() decorator handles the logic of calling dependencies and injecting them into the route handler, just like FastAPI would do internally.
